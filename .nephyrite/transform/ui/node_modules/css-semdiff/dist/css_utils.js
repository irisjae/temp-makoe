"use strict";
var Fs = require("fs");
var css = require("css");
var collection_utils_1 = require("./collection_utils");
var error_1 = require("./error");
function collectRuleNodes(styleSheet) {
    if (!(styleSheet.stylesheet && styleSheet.stylesheet.rules))
        throw error_1.NoRulesError.causedBy("the given one");
    return collection_utils_1.flatMap(styleSheet.stylesheet.rules, function (node) { return isRuleNode(node) ? [node] : []; });
}
exports.collectRuleNodes = collectRuleNodes;
/**
 * Whether the first node is equivalent to the second one.
 * This comparison is based on their hash values.
 * @see hashNode
 */
function nodeEquals(nodeA, nodeB) {
    return hashNode(nodeA) === hashNode(nodeB);
}
exports.nodeEquals = nodeEquals;
/**
 * Returns a hash value of the given node.
 *
 * The hash value should unique to css properties contained.
 * It means, following examples A and B should have the same hash value.
 *
 *     - Example A: { color: red; }
 *     - Example B: {\ncolor:red;\n}
 */
function hashNode(node) {
    return css.stringify(createDummyStyleSheet(node), { compress: true });
}
exports.hashNode = hashNode;
/**
 * Returns nodes that separated a slector group by their selectors.
 * We can equate the selector group 'a, b { ... }' to
 * the group 'b, a { ... }' and the group 'a { ... } b { ... }'.
 *
 * For example the selector group is like following:
 *
 *     a, b { color: red; }
 *
 * this function transform it to:
 *
 *     a { color: red; }
 *     b { color: red; }
 */
function uniformNode(node) {
    if (isRuleNode(node)) {
        return uniformRuleNode(node);
    }
    else {
        return [node];
    }
}
exports.uniformNode = uniformNode;
function uniformRuleNode(ruleNode) {
    if (!(ruleNode.selectors))
        throw error_1.NoSelectorsError.causedBy("the given one");
    return ruleNode.selectors.map(function (selector) { return ({
        type: ruleNode.type,
        parent: ruleNode.parent,
        position: ruleNode.position,
        selectors: [selector],
        declarations: ruleNode.declarations,
    }); });
}
function isRuleNode(node) {
    return node.type === "rule";
}
exports.isRuleNode = isRuleNode;
function parseFile(filePath) {
    return new Promise(function (resolve, reject) {
        Fs.readFile(filePath, "utf8", function (err, data) {
            if (err) {
                reject(err);
                return;
            }
            resolve(css.parse(data, { source: filePath }));
        });
    });
}
exports.parseFile = parseFile;
function stringifyCssNode(node) {
    // XXX: css.stringify can support only css.StyleSheet.
    //      So, we should create a dummy css.Stylesheet that
    //      have only a node to stringify.
    return css.stringify(createDummyStyleSheet(node));
}
exports.stringifyCssNode = stringifyCssNode;
function createDummyStyleSheet(node) {
    var parsingErrors = [];
    return {
        type: "stylesheet",
        stylesheet: {
            rules: [node],
            parsingErrors: parsingErrors,
        },
    };
}
exports.createDummyStyleSheet = createDummyStyleSheet;
var NodeSet = (function () {
    function NodeSet(nodes) {
        var _this = this;
        if (nodes === void 0) { nodes = []; }
        this.store = {};
        this.nodes = [];
        nodes.forEach(function (node) { return _this.add(node); });
    }
    NodeSet.prototype.sub = function (set) {
        return new NodeSet(collection_utils_1.flatMap(this.nodes, function (node) { return set.contains(node) ? [] : [node]; }));
    };
    NodeSet.prototype.add = function (node) {
        var hash = hashNode(node);
        if (hash in this.store) {
            return;
        }
        this.store[hash] = node;
        this.nodes.push(node);
    };
    NodeSet.prototype.contains = function (node) {
        var hash = hashNode(node);
        return hash in this.store;
    };
    NodeSet.prototype.toArray = function () {
        return collection_utils_1.clone(this.nodes);
    };
    return NodeSet;
}());
exports.NodeSet = NodeSet;
