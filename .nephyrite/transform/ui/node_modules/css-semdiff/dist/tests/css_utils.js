"use strict";
var assert = require("assert");
var css = require("css");
var css_utils_1 = require("../css_utils");
var error_1 = require("../error");
describe("NodeSet", function () {
    describe("#constructor", function () {
        it("should return an empty set when no args", function () {
            var set = new css_utils_1.NodeSet();
            assertSetEqual(set, []);
        });
        it("should return a set has a node when the node specified", function () {
            var node = createRuleNodeA();
            var set = new css_utils_1.NodeSet([node]);
            assertSetEqual(set, [node]);
        });
        it("should return a set has a node when the same node specified twice", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeA();
            var set = new css_utils_1.NodeSet([nodeA, nodeB]);
            assertSetEqual(set, [nodeA]);
        });
        it("should return a set has only the first node when two empty nodes specified " +
            "(NOTE: this behavior strongly depends css.stringify implementation)", function () {
            var nodeA = createNode("a {}");
            var nodeB = createNode("b {}");
            var set = new css_utils_1.NodeSet([nodeA, nodeB]);
            assertSetEqual(set, [nodeA]);
        });
        it("should return a set has two nodes when two nodes specified", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeB();
            var set = new css_utils_1.NodeSet([nodeA, nodeB]);
            assertSetEqual(set, [nodeA, nodeB]);
        });
        it("should return a set has two nodes when two nodes specified", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeB();
            var set = new css_utils_1.NodeSet([nodeA, nodeB]);
            assertSetEqual(set, [nodeA, nodeB]);
        });
    });
    describe("#add", function () {
        it("should return a set has a node when the node added", function () {
            var node = createRuleNodeA();
            var set = new css_utils_1.NodeSet();
            set.add(node);
            assertSetEqual(set, [node]);
        });
        it("should return a set has a node when the same node added twice", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeA();
            var set = new css_utils_1.NodeSet();
            set.add(nodeA);
            set.add(nodeB);
            assertSetEqual(set, [nodeA]);
        });
        it("should return a set has only the first node when two empty nodes added " +
            "(NOTE: this behavior strongly depends css.stringify implementation)", function () {
            var nodeA = createNode("a {}");
            var nodeB = createNode("b {}");
            var set = new css_utils_1.NodeSet();
            set.add(nodeA);
            set.add(nodeB);
            assertSetEqual(set, [nodeA]);
        });
        it("should return a set has two nodes when two nodes added", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeB();
            var set = new css_utils_1.NodeSet();
            set.add(nodeA);
            set.add(nodeB);
            assertSetEqual(set, [nodeA, nodeB]);
        });
        it("should return a set has two nodes when two nodes added", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeB();
            var set = new css_utils_1.NodeSet();
            set.add(nodeA);
            set.add(nodeB);
            assertSetEqual(set, [nodeA, nodeB]);
        });
    });
    describe("#sub", function () {
        it("should return an empty set when specified two empty sets", function () {
            var setA = new css_utils_1.NodeSet();
            var setB = new css_utils_1.NodeSet();
            assertSetEqual(setA.sub(setB), []);
        });
        it("should return a set has only a node when specified the set has the node and an empty set", function () {
            var nodeA = createRuleNodeA();
            var setA = new css_utils_1.NodeSet([nodeA]);
            var setB = new css_utils_1.NodeSet();
            assertSetEqual(setA.sub(setB), [nodeA]);
        });
        it("should return an empty set when specified an empty set and a set has several nodes", function () {
            var nodeA = createRuleNodeA();
            var setA = new css_utils_1.NodeSet();
            var setB = new css_utils_1.NodeSet([nodeA]);
            assertSetEqual(setA.sub(setB), []);
        });
        it("should return an empty set when specified both sets have a same node", function () {
            var nodeA = createRuleNodeA();
            var setA = new css_utils_1.NodeSet([nodeA]);
            var setB = new css_utils_1.NodeSet([nodeA]);
            assertSetEqual(setA.sub(setB), []);
        });
        it("should return an empty set when specified both sets have several same nodes", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeB();
            var setA = new css_utils_1.NodeSet([nodeA, nodeB]);
            var setB = new css_utils_1.NodeSet([nodeB, nodeA]);
            assertSetEqual(setA.sub(setB), []);
        });
        it("should return a set has only nodeB when specified a set has nodeA and nodeB, another set has nodeA", function () {
            var nodeA = createRuleNodeA();
            var nodeB = createRuleNodeB();
            var setA = new css_utils_1.NodeSet([nodeA, nodeB]);
            var setB = new css_utils_1.NodeSet([nodeA]);
            assertSetEqual(setA.sub(setB), [nodeB]);
        });
    });
});
function assertSetEqual(set, nodes) {
    assert.deepEqual(set.toArray(), nodes);
}
function createNode(cssText) {
    var result = css.parse(cssText);
    if (!(result.stylesheet && result.stylesheet.rules)) {
        throw error_1.NoRulesError.causedBy("the given one");
    }
    return result.stylesheet.rules[0];
}
function createRuleNodeA() {
    return createNode("a { display: none; }");
}
function createRuleNodeB() {
    return createNode("b { display: none; }");
}
